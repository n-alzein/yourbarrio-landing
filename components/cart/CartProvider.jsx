"use client";

import { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from "react";
import { useAuth } from "@/components/AuthProvider";

/** @typedef {import("@/lib/types/cart").CartResponse} CartResponse */

const CartContext = createContext({
  cart: null,
  vendor: null,
  items: [],
  itemCount: 0,
  loading: false,
  error: null,
  refreshCart: async () => {},
  addItem: async () => ({}),
  updateItem: async () => ({}),
  removeItem: async () => ({}),
  setFulfillmentType: async () => ({}),
  clearCart: async () => ({}),
});

/**
 * @param {Response} response
 * @returns {Promise<CartResponse>}
 */
async function parseResponse(response) {
  const text = await response.text();
  if (!text) return {};
  try {
    return JSON.parse(text);
  } catch {
    return {};
  }
}

const REFRESH_COOLDOWN_MS = 3000;
const CACHE_TTL_MS = 5000;

let globalRefreshInFlight = null;
let globalLastSuccessAt = 0;
let globalLastAttemptAt = 0;
let globalRefreshCalls = 0;
let globalMountCount = 0;
let globalUnmountCount = 0;
let globalStackHintEvery = 10;
let globalCache = { ts: 0, payload: null };

const getPerfDebug = () => {
  if (typeof window === "undefined") return false;
  try {
    if (process.env.NEXT_PUBLIC_PERF_DEBUG === "1") return true;
  } catch {}
  try {
    const params = new URLSearchParams(window.location.search);
    if (params.get("perf") === "1") return true;
  } catch {}
  try {
    return window.localStorage.getItem("PERF_DEBUG") === "1";
  } catch {
    return false;
  }
};

export function CartProvider({ children }) {
  const { user, authStatus } = useAuth();
  const [cart, setCart] = useState(null);
  const [vendor, setVendor] = useState(null);
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const abortRef = useRef(null);
  const lastRefreshKeyRef = useRef(null);
  const perfDebug = getPerfDebug();
  const mountStartedAtRef = useRef(0);

  const syncCart = useCallback((payload) => {
    setCart(payload?.cart || null);
    setVendor(payload?.vendor || null);
    setItems(payload?.cart?.cart_items || []);
  }, []);

  const refreshCart = useCallback(
    async ({ reason } = {}) => {
      if (!user?.id || authStatus !== "authenticated") {
        setCart(null);
        setVendor(null);
        setItems([]);
        setLoading(false);
        setError(null);
        return { cart: null };
      }

      globalRefreshCalls += 1;
      if (typeof globalThis !== "undefined") {
        globalThis.__cartRefreshCalls = globalRefreshCalls;
      }

      const now = Date.now();
      const lastSuccessAgoMs = globalLastSuccessAt ? now - globalLastSuccessAt : null;
      const lastAttemptAgoMs = globalLastAttemptAt ? now - globalLastAttemptAt : null;
      const cacheSource =
        typeof window !== "undefined" && window.__YB_CART_CACHE__
          ? window.__YB_CART_CACHE__
          : globalCache;
      const cacheFresh =
        cacheSource?.payload && now - cacheSource.ts < CACHE_TTL_MS;
      if (perfDebug) {
        const shouldLogStack = globalRefreshCalls % globalStackHintEvery === 0;
        console.log("[cart] refresh:attempt", {
          reason,
          mountCount: globalMountCount,
          refreshCalls: globalRefreshCalls,
          inFlight: Boolean(globalRefreshInFlight),
          lastSuccessAgoMs,
          lastAttemptAgoMs,
          stackHint: shouldLogStack ? new Error().stack : undefined,
        });
      }

      if (reason === "mount" && cacheFresh) {
        syncCart(cacheSource.payload);
        if (perfDebug) {
          console.log("[cart] refresh:skip", {
            reason,
            skip: "cache",
            cacheAgeMs: now - cacheSource.ts,
          });
        }
        return { skipped: true, skip: "cache", payload: cacheSource.payload };
      }

      if (globalRefreshInFlight) {
        if (perfDebug) {
          console.log("[cart] refresh:skip", {
            reason,
            skip: "in_flight",
            lastAttemptAgoMs,
          });
        }
        return { skipped: true, skip: "in_flight" };
      }
      if (
        reason === "mount" &&
        lastAttemptAgoMs != null &&
        lastAttemptAgoMs < REFRESH_COOLDOWN_MS
      ) {
        if (perfDebug) {
          console.log("[cart] refresh:skip", {
            reason,
            skip: "cooldown",
            lastAttemptAgoMs,
          });
        }
        return { skipped: true, skip: "cooldown" };
      }
      globalLastAttemptAt = now;

      if (abortRef.current?.abort) {
        abortRef.current.abort();
      }
      const controller = new AbortController();
      abortRef.current = controller;

      const runFetch = async () => {
        if (process.env.NEXT_PUBLIC_DEBUG_NAV_PERF === "1") {
          console.log("[cart] refresh:start", { reason });
        }
        setLoading(true);
        setError(null);
        try {
          const response = await fetch("/api/cart", {
            method: "GET",
            credentials: "same-origin",
            signal: controller.signal,
          });
          const payload = await parseResponse(response);
          if (!response.ok) {
            throw new Error(payload?.error || "Failed to load cart");
          }
          syncCart(payload);
          if (typeof window !== "undefined") {
            window.__YB_CART_CACHE__ = {
              ts: Date.now(),
              payload,
            };
          }
          globalCache = { ts: Date.now(), payload };
          globalLastSuccessAt = Date.now();
          return payload;
        } catch (err) {
          const message = err?.message || String(err);
          if (err?.name === "AbortError" || /aborted/i.test(message)) {
            return { aborted: true };
          }
          if (process.env.NEXT_PUBLIC_DEBUG_NAV_PERF === "1") {
            console.log("[cart] refresh:error", { message });
          }
          setError(message || "Failed to load cart");
          return { error: message || "Failed to load cart" };
        } finally {
          setLoading(false);
        }
      };

      globalRefreshInFlight = new Promise((resolve) => {
        if (typeof window !== "undefined" && typeof window.requestIdleCallback === "function") {
          window.requestIdleCallback(
            () => {
              runFetch().then(resolve);
            },
            { timeout: 1200 }
          );
        } else {
          setTimeout(() => {
            runFetch().then(resolve);
          }, 0);
        }
      }).finally(() => {
        globalRefreshInFlight = null;
      });

      return globalRefreshInFlight;
    },
    [authStatus, perfDebug, syncCart, user?.id]
  );

  useEffect(() => {
    if (!user?.id || authStatus !== "authenticated") return undefined;
    if (perfDebug) {
      if (typeof window !== "undefined") {
        globalMountCount += 1;
        window.__YB_CART_MOUNT_COUNT__ = globalMountCount;
        console.log("[cart] mount_count", window.__YB_CART_MOUNT_COUNT__);
        console.log("[cart] mount_path", window.location?.pathname);
      }
    }
    mountStartedAtRef.current = Date.now();
    const key = `${user.id}:${authStatus}`;
    if (lastRefreshKeyRef.current === key) return undefined;
    lastRefreshKeyRef.current = key;
    const run = () => refreshCart({ reason: "mount" });
    let idleId = null;
    let timeoutId = null;
    if (typeof window !== "undefined" && typeof window.requestIdleCallback === "function") {
      idleId = window.requestIdleCallback(run, { timeout: 1200 });
    } else {
      timeoutId = setTimeout(run, 0);
    }
    return () => {
      if (idleId && typeof window !== "undefined" && window.cancelIdleCallback) {
        window.cancelIdleCallback(idleId);
      }
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      if (abortRef.current?.abort) {
        abortRef.current.abort();
      }
      if (perfDebug && typeof window !== "undefined") {
        globalUnmountCount += 1;
        const mountedForMs = mountStartedAtRef.current
          ? Date.now() - mountStartedAtRef.current
          : null;
        console.log("[cart] unmount_count", globalUnmountCount);
        console.log("[cart] unmount_path", window.location?.pathname);
        console.log("[cart] mounted_for_ms", mountedForMs);
      }
    };
  }, [authStatus, refreshCart, syncCart, user?.id, perfDebug]);

  const addItem = useCallback(
    async ({ listingId, quantity = 1, clearExisting }) => {
      if (!user?.id) {
        return { error: "Please log in to add items." };
      }

      setError(null);
      const response = await fetch("/api/cart", {
        method: "POST",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          listing_id: listingId,
          quantity,
          clear_existing: clearExisting,
        }),
      });

      const payload = await parseResponse(response);
      if (!response.ok) {
        if (response.status === 409) {
          return { conflict: true, ...payload };
        }
        return { error: payload?.error || "Failed to add to cart" };
      }

      syncCart(payload);
      return { cart: payload?.cart || null, vendor: payload?.vendor || null };
    },
    [syncCart, user?.id]
  );

  const updateItem = useCallback(
    async ({ itemId, quantity }) => {
      if (!user?.id) {
        return { error: "Please log in." };
      }

      const response = await fetch("/api/cart", {
        method: "PATCH",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ item_id: itemId, quantity }),
      });

      const payload = await parseResponse(response);
      if (!response.ok) {
        return { error: payload?.error || "Failed to update cart" };
      }

      syncCart(payload);
      return payload;
    },
    [syncCart, user?.id]
  );

  const removeItem = useCallback(
    async (itemId) => updateItem({ itemId, quantity: 0 }),
    [updateItem]
  );

  const setFulfillmentType = useCallback(
    async (fulfillmentType) => {
      if (!user?.id) {
        return { error: "Please log in." };
      }

      const response = await fetch("/api/cart", {
        method: "PATCH",
        credentials: "include",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ fulfillment_type: fulfillmentType }),
      });

      const payload = await parseResponse(response);
      if (!response.ok) {
        return { error: payload?.error || "Failed to update fulfillment" };
      }

      syncCart(payload);
      return payload;
    },
    [syncCart, user?.id]
  );

  const clearCart = useCallback(async () => {
    if (!user?.id) {
      return { error: "Please log in." };
    }

    const response = await fetch("/api/cart", {
      method: "DELETE",
      credentials: "include",
    });

    const payload = await parseResponse(response);
    if (!response.ok) {
      return { error: payload?.error || "Failed to clear cart" };
    }

    syncCart(payload);
    return payload;
  }, [syncCart, user?.id]);

  const itemCount = useMemo(
    () => items.reduce((sum, item) => sum + Number(item.quantity || 0), 0),
    [items]
  );

  const value = useMemo(
    () => ({
      cart,
      vendor,
      items,
      itemCount,
      loading,
      error,
      refreshCart,
      addItem,
      updateItem,
      removeItem,
      setFulfillmentType,
      clearCart,
    }),
    [
      cart,
      vendor,
      items,
      itemCount,
      loading,
      error,
      refreshCart,
      addItem,
      updateItem,
      removeItem,
      setFulfillmentType,
      clearCart,
    ]
  );

  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
}

export function useCart() {
  return useContext(CartContext);
}
